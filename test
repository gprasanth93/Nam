Hereâ€™s a draft for your internal blog post titled:

â¸»

How We Scaled PostgreSQL Time-Series Monitoring with TimescaleDB and WebSockets in PgMaker

ğŸ“… May 2025 â€“ Engineering Blog

â¸»

ğŸ§© Introduction

As part of PgMakerâ€™s vision to simplify and scale database deployment on KVM infrastructure, we recently rolled out a centralized time-series monitoring service built on TimescaleDB. This system captures live metrics from every KVM VM via WebSocket and pipes it into a single scalable PostgreSQL hypertable. The results? A seamless monitoring experience in Grafana and a foundation for intelligent KVM resource management.

â¸»

ğŸ“¡ Real-Time Data via WebSockets

Every KVM spun up by PgMaker is configured to stream system statistics to a central service over WebSocket every 2 minutes. These metrics include:
	â€¢	Total Memory
	â€¢	Used Memory %
	â€¢	CPU Used %
	â€¢	Disk & Swap Used %
	â€¢	dbState (e.g., PRIMARY, STANDBY, UNHEALTHY)
	â€¢	supervisorState flags

Each KVM sends a structured JSON packet containing its identity and system usage. The backend listens concurrently to over 200 active WebSocket streams per host using lightweight Node.js services, efficiently inserting them into a TimescaleDB hypertable.

â¸»

ğŸ§  Why TimescaleDB?

TimescaleDB, built on PostgreSQL, is purpose-built for time-series workloads. Some of its key benefits for our use case include:
	â€¢	âœ… Efficient ingestion at scale (handles tens of millions of rows without breaking a sweat)
	â€¢	âœ… Powerful time-window queries for alerts, summaries, and dashboards
	â€¢	âœ… Native PostgreSQL compatibility, making integration and tooling dead simple
	â€¢	âœ… Hypertables for auto-partitioning and time-indexing
	â€¢	âœ… Seamless integration with Grafana for real-time visualization

With TimescaleDB, we didnâ€™t need to change our database stack â€” just enhanced it for time-awareness.

â¸»

ğŸ“Š Scaling: How Much Data Are We Managing?

Letâ€™s do some back-of-the-envelope math:
	â€¢	ğŸ”„ Every KVM sends a record every 2 mins
	â€¢	ğŸ“¦ Each metric insert = 1 row
	â€¢	ğŸ§± 200 KVMs per host
	â€¢	ğŸŒ 15 hosts currently online

ğŸ§® Daily Volume:

200 KVMs x 15 hosts = 3000 VMs
Every 2 mins â†’ 30 inserts/hour â†’ 720 inserts/day

3000 VMs Ã— 720 = 2,160,000 rows/day

ğŸ“ˆ Monthly:

~65 million rows/month in a single hypertable

Thanks to TimescaleDBâ€™s automatic chunking and PostgreSQL-native indexing, we handle this load with sub-second query latency.

â¸»

ğŸ“‰ Visualization with Grafana

Our Grafana dashboards are powered directly by TimescaleDB queries. Using dashboard variables, we built filters for:
	â€¢	Region (UK, US, HK)
	â€¢	dbName or Hostname
	â€¢	Time range
	â€¢	Metric type (CPU, Memory, Disk, etc.)

Panels display:
	â€¢	Live stats per KVM
	â€¢	Historical graphs (last 24h, 7d)
	â€¢	Heatmaps of unhealthy states

The best part? We query one unified hypertable, and the dashboard can switch between regions using dynamic data source variables.

â¸»

ğŸ”­ Whatâ€™s Next?

This architecture lays the groundwork for intelligent, adaptive infrastructure.

ğŸš€ Upcoming Enhancements:
	â€¢	ğŸ§  Auto-scaling recommendations: Predict KVM size upgrades/downgrades based on historical trends.
	â€¢	ğŸ“ˆ Anomaly detection: Flag KVMs with unusual CPU/memory patterns.
	â€¢	ğŸ”” Alerting pipelines: Notify teams of degraded or unhealthy KVMs using Timescale query triggers or Grafana alerts.
	â€¢	ğŸ’¾ Retention tuning: Optimize disk via retention policies, offloading stale data to S3 or Glacier.

â¸»

ğŸ¤– Future: Autonomous KVM Tuning?

Imagine:
	â€¢	A small KVM starts hitting 80% memory regularly.
	â€¢	Our system detects it.
	â€¢	PgMaker provisions a larger KVM and auto-promotes.

Weâ€™re building the foundation to let metrics not just inform us â€” but automate our infrastructure.

â¸»

ğŸ§© Summary

Component	Stack Used
Ingestion	Node.js + WebSockets
Time-series DB	PostgreSQL + TimescaleDB
Dashboarding	Grafana + PostgreSQL plugin
Scale	~2M rows/day, growing monthly
Storage	Single hypertable w/ chunking


â¸»

ğŸ§  Takeaway

With TimescaleDB and WebSockets, we built a lightweight, scalable, and future-proof monitoring solution that empowers our KVM database infrastructure to be observable, adaptable, and soon â€” self-optimizing.

Let the metrics guide us. ğŸš€

â¸»

Let me know if you want a version for external publication, or an internal version with deeper infrastructure stats/logs!