const express = require('express');
const { spawn, exec } = require('child_process');
const util = require('util');
const path = require('path');
const bodyParser = require('body-parser');

const execPromise = util.promisify(exec);
const app = express();
const serverPort = 3000;

// Middleware to parse JSON bodies.
app.use(bodyParser.json());

// Initial KVM configurations.
const kvmConfigs = [
  { hostPort: 8001, targetIp: '192.168.122.101', targetPort: 22, databaseName: 'db1' },
  { hostPort: 8002, targetIp: '192.168.122.102', targetPort: 22, databaseName: 'db2' }
];

/**
 * Async arrow function to list running socat wrapper processes.
 * It executes a "ps" command and parses lines that include "socat_wrapper.sh".
 * Expected command line format:
 *   socat_wrapper.sh <hostPort> <targetIp> <targetPort> <databaseName>
 *
 * @returns {Promise<Array>} Array of process objects.
 */
const listSocatProcesses = async () => {
  try {
    const { stdout } = await execPromise('ps -eo pid,command');
    const lines = stdout.split('\n');
    const socatProcesses = [];
    for (const line of lines) {
      if (line.includes('socat_wrapper.sh')) {
        // Example line:
        // "12345 /path/to/socat_wrapper.sh 8001 192.168.122.101 22 db1"
        const match = line.match(/^\s*(\d+).*socat_wrapper\.sh\s+(\d+)\s+([\d.]+)\s+(\d+)\s+(\S+)/);
        if (match) {
          socatProcesses.push({
            pid: parseInt(match[1], 10),
            hostPort: parseInt(match[2], 10),
            targetIp: match[3],
            targetPort: parseInt(match[4], 10),
            databaseName: match[5],
            fullCommand: line.trim()
          });
        }
      }
    }
    return socatProcesses;
  } catch (error) {
    throw new Error(`Error executing ps: ${error.message}`);
  }
};

/**
 * Async arrow function to add a new socat process using the wrapper script.
 * Before starting, it checks if a process with the same databaseName is already running.
 *
 * @param {Object} config - Contains hostPort, targetIp, targetPort, and databaseName.
 * @returns {Promise<Object>} - A result object with a message and the configuration.
 */
const addSocatProcess = async (config) => {
  const processes = await listSocatProcesses();
  const exists = processes.find(proc => proc.databaseName === config.databaseName);
  if (exists) {
    console.log(`Socat process already running for databaseName: ${config.databaseName}. Skipping.`);
    return { message: 'Process already running', config };
  }
  // Build the full path to the wrapper script.
  const wrapperPath = path.join(__dirname, 'socat_wrapper.sh');
  const args = [
    config.hostPort,
    config.targetIp,
    config.targetPort,
    config.databaseName
  ];

  // Spawn the wrapper script in detached mode.
  const proc = spawn(wrapperPath, args, {
    detached: true,
    stdio: 'ignore'
  });
  proc.unref();

  console.log(`Started socat wrapper: Host Port ${config.hostPort} -> ${config.targetIp}:${config.targetPort} with databaseName: ${config.databaseName}`);
  return { message: 'Process started', config };
};

/**
 * Async arrow function to stop (kill) socat wrapper processes that match the given databaseName.
 *
 * @param {string} databaseName - The tag provided when starting the socat process.
 * @returns {Promise<Object>} - A result object with a message.
 */
const stopSocatProcess = async (databaseName) => {
  const processes = await listSocatProcesses();
  const procsToKill = processes.filter(proc => proc.databaseName === databaseName);
  if (procsToKill.length === 0) {
    throw new Error(`No socat process found with databaseName: ${databaseName}`);
  }
  const killPromises = procsToKill.map(proc => {
    return execPromise(`kill ${proc.pid}`).then(() => {
      console.log(`Killed socat process with PID ${proc.pid} for databaseName: ${databaseName}`);
      return { pid: proc.pid, success: true };
    });
  });
  const results = await Promise.all(killPromises);
  return { message: `Stopped ${results.length} process(es) with databaseName: ${databaseName}` };
};

/**
 * Async arrow function to initialize socat processes for all initial KVM configurations.
 */
const initializeSocatProcesses = async () => {
  const promises = kvmConfigs.map(config => addSocatProcess(config));
  await Promise.all(promises);
};

// Initialize socat processes on startup.
initializeSocatProcesses().catch(err => console.error(`Error initializing socat processes: ${err.message}`));

/* ===== HTTP Endpoints ===== */

// GET /socat-mappings: List all running socat wrapper processes.
app.get('/socat-mappings', async (req, res) => {
  try {
    const processes = await listSocatProcesses();
    res.json(processes);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// POST /socat-add: Add a new socat process.
// Expected JSON body: { hostPort, targetIp, targetPort, databaseName }
app.post('/socat-add', async (req, res) => {
  const { hostPort, targetIp, targetPort, databaseName } = req.body;
  if (!hostPort || !targetIp || !targetPort || !databaseName) {
    return res.status(400).json({ error: 'Missing required parameters.' });
  }
  try {
    const result = await addSocatProcess({ hostPort, targetIp, targetPort, databaseName });
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// DELETE /socat-remove: Stop a socat process.
// Expected JSON body: { databaseName }
app.delete('/socat-remove', async (req, res) => {
  const { databaseName } = req.body;
  if (!databaseName) {
    return res.status(400).json({ error: 'Missing databaseName parameter.' });
  }
  try {
    const result = await stopSocatProcess(databaseName);
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Start the Express server.
app.listen(serverPort, () => {
  console.log(`Server is running on port ${serverPort}`);
});
