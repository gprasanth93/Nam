DO $$
DECLARE 
    pg_version INT;
    has_procreated BOOLEAN;
    query TEXT;
BEGIN
    -- Get PostgreSQL version number
    SELECT setting::INT INTO pg_version FROM pg_settings WHERE name = 'server_version_num';

    -- Check if `procreated` and `promodified` exist in `pg_proc` (PostgreSQL 16+)
    SELECT COUNT(*) > 0 INTO has_procreated
    FROM pg_attribute 
    WHERE attrelid = 'pg_proc'::regclass 
    AND attname IN ('procreated', 'promodified');

    -- Construct the base query dynamically
    query := '
    WITH functions_procedures AS (
        SELECT 
            p.proname::TEXT AS object_name,  
            n.nspname::TEXT AS schema_name,  
            pg_catalog.pg_get_function_result(p.oid)::TEXT AS return_type,  
            pg_catalog.pg_get_function_arguments(p.oid)::TEXT AS arguments,  
            CASE 
                WHEN p.prokind = ''f'' THEN ''FUNCTION''
                WHEN p.prokind = ''p'' THEN ''PROCEDURE''
                ELSE ''OTHER''
            END::TEXT AS object_type,  
            r.rolname::TEXT AS owner,  
            l.lanname::TEXT AS language,  
            p.prosrc::TEXT AS definition,  
            COALESCE(p.proacl::TEXT, ''NULL'') AS privileges,  
            pg_catalog.obj_description(p.oid, ''pg_proc'')::TEXT AS description,  
            p.probin::TEXT AS binary_path,  
            p.provolatile::TEXT AS volatility,  
            p.proisstrict::TEXT AS is_strict,  
            p.prosecdef::TEXT AS security_definer,  
            p.proparallel::TEXT AS parallel_mode';

    -- Add `procreated` and `promodified` columns dynamically if PostgreSQL is 16+
    IF has_procreated THEN
        query := query || ',
            p.procreated::TEXT AS created_at,
            p.promodified::TEXT AS last_modified_at';
    ELSE
        query := query || ',
            NULL::TEXT AS created_at,
            NULL::TEXT AS last_modified_at';
    END IF;

    -- Complete the query
    query := query || '
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        JOIN pg_roles r ON p.proowner = r.oid  
        JOIN pg_language l ON p.prolang = l.oid  
        WHERE n.nspname NOT IN (''pg_catalog'', ''information_schema'')
    ),
    triggers AS (
        SELECT 
            t.tgname::TEXT AS object_name,  
            n.nspname::TEXT AS schema_name,  
            ''N/A''::TEXT AS return_type,  
            string_agg(a.attname, '', '')::TEXT AS arguments,
            ''TRIGGER''::TEXT AS object_type,  
            r.rolname::TEXT AS owner,  
            NULL::TEXT AS language,  
            pg_get_triggerdef(t.oid)::TEXT AS definition,  
            NULL::TEXT AS privileges,  
            pg_catalog.obj_description(t.oid, ''pg_trigger'')::TEXT AS description,  
            NULL::TEXT AS binary_path,  
            NULL::TEXT AS volatility,  
            NULL::TEXT AS is_strict,  
            NULL::TEXT AS security_definer,  
            NULL::TEXT AS parallel_mode,  
            NULL::TEXT AS created_at,  
            NULL::TEXT AS last_modified_at
        FROM pg_trigger t
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        JOIN pg_roles r ON c.relowner = r.oid  
        LEFT JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(t.tgattr)
        WHERE NOT t.tgisinternal  
        GROUP BY t.tgname, n.nspname, c.relowner, t.oid, r.rolname
    )
    SELECT * FROM functions_procedures
    UNION ALL
    SELECT * FROM triggers
    ORDER BY last_modified_at DESC NULLS LAST, created_at DESC NULLS LAST;
    ';

    -- Execute the dynamically built query
    EXECUTE query;
END $$;