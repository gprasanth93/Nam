Totally doable—add a tiny formatter and use it in the IO cell.

1) Add these helpers (top of the file, above the component)

// Format a rate that is stored in KB/s to KB/s, MB/s, or GB/s
function rateFromKBps(vKBps = 0) {
  const a = Math.abs(vKBps);
  if (a >= 1024 * 1024) return { val: vKBps / (1024 * 1024), unit: "GB/s" };
  if (a >= 1024)        return { val: vKBps / 1024,           unit: "MB/s" };
  return { val: vKBps, unit: "KB/s" };
}

// If your source is **bytes/s**, use this instead:
// function rateFromBps(vBps = 0) {
//   const KBps = vBps / 1024;
//   return rateFromKBps(KBps);
// }

function fmt(n, maxFrac = 1) {
  return Number(n || 0).toLocaleString(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: maxFrac,
  });
}

2) Make your Seg accept custom display strings

Replace your Seg with this version (keeps bars but lets you print any text next to them):

function Seg({
  label,
  leftValue,
  rightValue,
  unit = "%",
  leftName = "",
  rightName = "",
  leftText,   // if provided, shown instead of `${leftValue}${unit}`
  rightText,  // if provided, shown instead of `${rightValue}${unit}`
}) {
  const leftMain  = leftText  ?? `${Math.round(leftValue)}${unit}`;
  const rightMain = rightText ?? `${Math.round(rightValue)}${unit}`;

  return (
    <Stack gap={6}>
      <Text size="xs" c="dimmed">{label}</Text>

      <Group justify="space-between" align="center">
        <Group gap={4} wrap="nowrap" align="baseline">
          <Text fz={12} c="teal" fw={700} lh={1}>{leftMain}</Text>
          {leftName && <Text span fz={10} c="teal.4" fw={600} lh={1}>{leftName}</Text>}
        </Group>
        <Group gap={4} wrap="nowrap" align="baseline">
          <Text fz={12} c="red" fw={700} lh={1}>{rightMain}</Text>
          {rightName && <Text span fz={10} c="red.4" fw={600} lh={1}>{rightName}</Text>}
        </Group>
      </Group>

      <Progress.Root size="xs">
        <Progress.Section value={leftValue}  color="green" />
        <Progress.Section value={rightValue} color="red" />
      </Progress.Root>
    </Stack>
  );
}

3) Use it in the IO column

Where you render the IO cell in your table row, compute the display strings once and pass them:

// Assuming your row has p95 write/read rates in KB/s:
const wKBps = Number(r.ioWriteKBps ?? r.ioWriteKBs ?? 0); // adapt to your field name
const rKBps = Number(r.ioReadKBps  ?? r.ioReadKBs  ?? 0);

// Convert to nice units
const wRate = rateFromKBps(wKBps);
const rRate = rateFromKBps(rKBps);

// Text to show next to the bars
const wText = `${fmt(wRate.val)} ${wRate.unit}`;
const rText = `${fmt(rRate.val)} ${rRate.unit}`;

// Your percent bars (0–100) stay as you already compute them:
const wPct = Math.max(0, Math.min(100, r.ioWritePct ?? 0));
const rPct = Math.max(0, Math.min(100, r.ioReadPct  ?? 0));

/* ...inside <Table.Td> for IO... */
<Seg
  label="IO p95"
  leftValue={wPct}
  rightValue={rPct}
  leftText={wText}
  rightText={rText}
  leftName="Write"
  rightName="Read"
/>

That’s it. Now 69350 KB/s becomes 67.8 MB/s, 1 230 263 KB/s becomes 1.17 GB/s, etc., and the labels stay tight next to the numbers. If your source rates are bytes/s instead of KB/s, switch the helper to rateFromBps.