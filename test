DO $$ 
DECLARE 
    pg_version INT;
    has_procreated BOOLEAN;
    query TEXT;
BEGIN
    -- Get PostgreSQL version number
    SELECT setting::INT INTO pg_version FROM pg_settings WHERE name = 'server_version_num';

    -- Check if procreated and promodified exist in pg_proc (PostgreSQL 16+)
    SELECT COUNT(*) > 0 INTO has_procreated 
    FROM pg_attribute 
    WHERE attrelid = 'pg_proc'::regclass 
    AND attname IN ('procreated', 'promodified');

    -- Construct the base query
    query := '
    WITH functions_procedures AS (
        SELECT 
            p.proname AS object_name,  
            n.nspname AS schema_name,  
            pg_catalog.pg_get_function_result(p.oid) AS return_type,  
            pg_catalog.pg_get_function_arguments(p.oid) AS arguments,
            CASE 
                WHEN p.prokind = ''f'' THEN ''FUNCTION''
                WHEN p.prokind = ''p'' THEN ''PROCEDURE''
                ELSE ''OTHER''
            END AS object_type,  
            r.rolname AS owner,  
            l.lanname AS language,  
            p.prosrc AS definition,  
            p.proacl AS privileges,  
            pg_catalog.obj_description(p.oid, ''pg_proc'') AS description,  
            p.probin AS binary_path,  
            p.provolatile AS volatility,  
            p.proisstrict AS is_strict,  
            p.prosecdef AS security_definer,  
            p.proparallel AS parallel_mode';

    -- Append procreated and promodified conditionally
    IF has_procreated THEN
        query := query || ',
            p.procreated AS created_at,  
            p.promodified AS last_modified_at';
    ELSE
        query := query || ',
            NULL::TIMESTAMP AS created_at,  
            NULL::TIMESTAMP AS last_modified_at';
    END IF;

    -- Complete the query
    query := query || '
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        JOIN pg_roles r ON p.proowner = r.oid  
        JOIN pg_language l ON p.prolang = l.oid  
        WHERE n.nspname NOT IN (''pg_catalog'', ''information_schema'')
    ),
    triggers AS (
        SELECT 
            t.tgname AS object_name,  
            n.nspname AS schema_name,  
            ''N/A'' AS return_type,  
            string_agg(a.attname, '', '') AS arguments,  
            ''TRIGGER'' AS object_type,  
            r.rolname AS owner,  
            NULL AS language,  
            pg_get_triggerdef(t.oid) AS definition,  
            NULL AS privileges,  
            pg_catalog.obj_description(t.oid, ''pg_trigger'') AS description,  
            NULL AS binary_path,  
            NULL AS volatility,  
            NULL AS is_strict,  
            NULL AS security_definer,  
            NULL AS parallel_mode,  
            NULL AS created_at,  
            NULL AS last_modified_at  
        FROM pg_trigger t
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        JOIN pg_roles r ON c.relowner = r.oid  
        LEFT JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(t.tgattr)
        WHERE NOT t.tgisinternal  
        GROUP BY t.tgname, n.nspname, c.relowner, t.oid, r.rolname
    )
    SELECT * FROM functions_procedures
    UNION ALL
    SELECT * FROM triggers
    ORDER BY last_modified_at DESC NULLS LAST, created_at DESC NULLS LAST;
    ';

    -- Execute the dynamically built query
    EXECUTE query;
END $$;