Perfect—thanks for the schema photo. Below is a ready-to-run migration + hourly rotation pack tailored to your public.logs table (UUID PK, quoted "timestamp", hostname, database, etc.). It:
	1.	creates an hourly-partitioned replacement,
	2.	pre-creates the needed hour partitions,
	3.	moves the last 2 hours from the old table, deletes those rows from the old table in safe batches,
	4.	atomically swaps names so apps keep using public.logs, and
	5.	installs a pg_cron rotation to create future partitions and drop old ones by retention.

Adjust the RETENTION_HOURS near the bottom to what you want (example keeps 7 days = 168 hours).

⸻

0) One-time: functions to manage hourly partitions

-- 0.a  Create a child for the given hour: [hour, hour+1h)
CREATE OR REPLACE FUNCTION public.ensure_hour_partition(_parent regclass, _hour timestamptz)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  from_ts timestamptz := date_trunc('hour', _hour);
  to_ts   timestamptz := from_ts + interval '1 hour';
  part_name text := format('%s_%s',
                           _parent::text,
                           to_char(from_ts AT TIME ZONE 'UTC','YYYYMMDD_HH24'));
BEGIN
  EXECUTE format($fmt$
    CREATE TABLE IF NOT EXISTS %I PARTITION OF %s
    FOR VALUES FROM (%L) TO (%L)
  $fmt$, part_name, _parent, from_ts, to_ts);
END$$;


-- 0.b  Drop partitions older than cutoff (by lower bound), accurate & name-agnostic
CREATE OR REPLACE FUNCTION public.drop_old_hour_partitions(_parent regclass, _retain_hours int)
RETURNS int
LANGUAGE plpgsql
AS $$
DECLARE
  cutoff timestamptz := date_trunc('hour', now()) - make_interval(hours => _retain_hours);
  r record;
  dropped int := 0;
BEGIN
  FOR r IN
    SELECT c.oid::regclass AS child,
           regexp_match(pg_get_expr(c.relpartbound, c.oid), '\(([^,]+),')[1]::timestamptz AS lower_bound
    FROM pg_inherits i
    JOIN pg_class   c ON c.oid = i.inhrelid
    WHERE i.inhparent = _parent
  LOOP
    IF r.lower_bound < cutoff THEN
      EXECUTE format('DROP TABLE IF EXISTS %s', r.child);
      dropped := dropped + 1;
    END IF;
  END LOOP;
  RETURN dropped;
END$$;


-- 0.c  Hourly rotation entrypoint (ensure current/next, drop old, analyze)
CREATE OR REPLACE PROCEDURE public.rotate_hourly_partitions(_parent regclass, _retain_hours int)
LANGUAGE plpgsql
AS $$
DECLARE
  curr_hour timestamptz := date_trunc('hour', now());
BEGIN
  PERFORM public.ensure_hour_partition(_parent, curr_hour);
  PERFORM public.ensure_hour_partition(_parent, curr_hour + interval '1 hour');
  PERFORM public.drop_old_hour_partitions(_parent, _retain_hours);
  EXECUTE format('ANALYZE %s', _parent);
END$$;


⸻

1) Create the new partitioned parent logs_p (same columns, hourly range)

BEGIN;

-- Parent with identical columns/constraints/defaults as your current table
CREATE TABLE IF NOT EXISTS public.logs_p (
  rowid uuid NOT NULL DEFAULT uuid_in(md5(random()::text || clock_timestamp()::text)::cstring),
  "timestamp" timestamptz NULL,
  hostname varchar(255) NULL,
  "label" varchar(255) NULL,
  "database" varchar(255) NULL,
  metadata jsonb NULL,
  message text NULL,
  CONSTRAINT logs_p_pkey PRIMARY KEY (rowid)
) PARTITION BY RANGE ("timestamp");

-- Partitioned (inherited) indexes. Postgres will create child indexes per partition.
CREATE INDEX IF NOT EXISTS logs_p_ts_btree     ON public.logs_p ("timestamp");
CREATE INDEX IF NOT EXISTS logs_p_hostname_idx ON public.logs_p (hostname);
CREATE INDEX IF NOT EXISTS logs_p_database_idx ON public.logs_p ("database");

COMMIT;


⸻

2) Pre-create partitions for the last 2 hours, current, and next hour

DO $$
DECLARE
  h timestamptz := date_trunc('hour', now()) - interval '2 hour';
  stop timestamptz := date_trunc('hour', now()) + interval '1 hour';
BEGIN
  WHILE h <= stop LOOP
    PERFORM public.ensure_hour_partition('public.logs_p'::regclass, h);
    h := h + interval '1 hour';
  END LOOP;
END$$;


⸻

3) Move the last 2 hours from old public.logs into public.logs_p,

then delete from old in safe batches

-- 3.a Insert the last 2 hours (adjust window if you like)
WITH win AS (
  SELECT date_trunc('hour', now()) - interval '2 hour' AS start_ts,
         date_trunc('hour', now())                     AS end_ts
)
INSERT INTO public.logs_p
SELECT l.*
FROM public.logs l
JOIN win w ON l."timestamp" >= w.start_ts AND l."timestamp" < w.end_ts;

-- 3.b Batched delete from old table (keeps WAL/vacuum sane). Re-run until 0 rows.
DO $$
DECLARE
  batch_count int;
BEGIN
  LOOP
    WITH victim AS (
      SELECT ctid
      FROM public.logs
      WHERE "timestamp" >= date_trunc('hour', now()) - interval '2 hour'
        AND "timestamp" <  date_trunc('hour', now())
      LIMIT 50000
    )
    DELETE FROM public.logs l
    USING victim v
    WHERE l.ctid = v.ctid
    RETURNING 1
    INTO batch_count;

    EXIT WHEN NOT FOUND;  -- no more rows in the window
    PERFORM pg_sleep(0.05); -- tiny breather for autovacuum
  END LOOP;
END$$;

-- Optional stats refresh
VACUUM (ANALYZE) public.logs_p;


⸻

4) Atomic swap: make partitioned table become public.logs

BEGIN;
LOCK TABLE public.logs IN ACCESS EXCLUSIVE MODE;

-- Keep a dated backup name for the old heap
ALTER TABLE public.logs RENAME TO logs_old_utc_||
to_char((now() AT TIME ZONE 'UTC'),'YYYYMMDD_HH24MISS');  -- (run as two statements)

-- PostgreSQL doesn’t allow concatenation inside ALTER; do it explicitly:
-- Example:
-- ALTER TABLE public.logs RENAME TO logs_old_20250915_221530;

ALTER TABLE public.logs_p RENAME TO logs;

-- Fix index/constraint names if you care about exact names (optional)
-- (The partitioned indexes/PK already moved with the parent.)

COMMIT;

If you want me to emit the exact RENAME TO logs_old_YYYYMMDD_HHMMSS line based on your clock, just say the word and I’ll format it.

⸻

5) Schedule pg_cron to rotate hourly & drop old partitions

-- Choose your retention here:
-- e.g., keep 7 days of logs => 168 hours
DO $$ BEGIN
  PERFORM cron.schedule(
    'logs_partition_rotate_hourly',
    '1 * * * *',   -- at minute 01 of every hour
    $$CALL public.rotate_hourly_partitions('public.logs'::regclass, 168);$$
  );
EXCEPTION WHEN unique_violation THEN
  -- job already exists: update it
  PERFORM cron.update(job_name := 'logs_partition_rotate_hourly',
                      schedule := '1 * * * *',
                      command  := $$CALL public.rotate_hourly_partitions('public.logs'::regclass, 168);$$);
END$$;


⸻

Notes / knobs
	•	Your column is literally named "timestamp"; the script keeps it quoted everywhere.
	•	Because the PK is a UUID (no sequence), there’s no sequence work to do.
	•	If you also log heavily on hostname/database filters, keeping those partitioned indexes is fine. If space is tight, drop whichever you don’t query.
	•	For very high ingest, consider adding a BRIN on "timestamp" on each child too (cheap):
CREATE INDEX IF NOT EXISTS logs_p_ts_brin ON public.logs_p USING brin ("timestamp");

⸻

If you share the exact old table name you want for step 4 (e.g., logs_old_20250915_2000), I’ll emit the literal swap block so you can paste it verbatim.